}
theResponse2 = log(pmax(theResponse + 15, 0))
colnames(theData)
theResponse2 = log(pmax(theResponse + 15, 0))
covariates = c("Quarter", "PossessionTeam", "Down", "Distance", "OffenseFormation",
"DefendersInTheBox", "Turf", "GameWeather", "DistanceToGoal", "DistanceToLOS",
"RusherInfo_Acc", "RusherInfo_DistDef", "RusherInfo_DistLOS",
"RusherInfo_Pos", "RusherInfo_SpeedX", "RusherInfo_SpeedY" )
categorical = c("Quarter", "PossessionTeam", "Down", "OffenseFormation", "Turf", "GameWeather", "RusherInfo_Pos")
theData2 = theData %>%
select(covariates) %>%
mutate_at(vars(categorical), as.factor)
modelFnc = rai
# modelFnc = runLM
predictCV(theResponse2, theData2, modelFnc)
dim(theData)
length(theResponse)
theData = loadData("trainClean_py.csv")
theResponse = loadData("trainResponse_py.csv") %>%
pull(Yards)
dim(theData)
length(theResponse)
anti_join(theDat, theResponse, by=PlayId)
anti_join(theData, theResponse, by=PlayId)
theResponse = loadData("trainResponse_py.csv")
anti_join(theData, theResponse, by=PlayId)
anti_join(theData, theResponse, by="PlayId")
library(knitr)
opts_chunk$set(echo = TRUE,
collapse = FALSE,
comment = "",
strip.white = TRUE,
warning = FALSE,
message = FALSE,
out.width = "70%",
fig.align = "center")
df %>%
summarise_all(function(col) sum(is.na(col)))
theData = loadData("trainClean_py.csv")
theResponse = loadData("trainResponse_py.csv") %>%
pull(Yards)
dim(theData); length(theResponse)
theResponse2 = log(pmax(theResponse + 15, 0))
covariates = c("Quarter", "PossessionTeam", "Down", "Distance", "OffenseFormation",
"DefendersInTheBox", "Turf", "GameWeather", "DistanceToGoal", "DistanceToLOS",
"RusherInfo_Acc", "RusherInfo_DistDef", "RusherInfo_DistLOS",
"RusherInfo_Pos", "RusherInfo_SpeedX", "RusherInfo_SpeedY" )
categorical = c("Quarter", "PossessionTeam", "Down", "OffenseFormation", "Turf", "GameWeather", "RusherInfo_Pos")
theData2 = theData %>%
select(covariates) %>%
mutate_at(vars(categorical), as.factor)
modelFnc = rai
# modelFnc = runLM
predictCV(theResponse2, theData2, modelFnc)
library(knitr)
opts_chunk$set(echo = TRUE,
collapse = FALSE,
comment = "",
strip.white = TRUE,
warning = FALSE,
message = FALSE,
out.width = "70%",
fig.align = "center")
library(tidyverse)
library(magrittr)
library(modelr)  # for cv
# devtools::install_github("korydjohnson/rai")
library(rai)
loadData <- function(fileName = "train.csv", ...) {
file = paste("../input", fileName, sep="/")
data.table::fread(file, ...) %>%
as_tibble()
}
theData = loadData("trainClean_py.csv")
theResponse = loadData("trainResponse_py.csv") %>%
pull(Yards)
dim(theData); length(theResponse)
# theData
a = 112.75760456
b = 103.6066858
x = seq(0, 198)/198
beta = dbeta(x, a, b)
dfBeta = tibble(x, beta)
dfBeta %>%
filter(beta > .001) %>%
ggplot() +
geom_line(aes(x*199-99, beta))
mu = a/(a+b)
sig = sqrt(a*b/((a+b)^2*(a+b+1)))
dfBeta %<>%
mutate(normal = dnorm(x, mu, sig))
dfBeta %>%
gather("dist", "density", beta, normal) %>%
filter(density > .01) %>%
ggplot() +
geom_line(aes(x, density, color=dist))
runLM = function(theData, theResponse) {
lm(theResponse ~ ., data=theData)
}
getProbs = function(est, sd, rangeY=NULL) {
if (is.null(rangeY)) {
rangeY = log(pmax(seq(-99,99) + 15, 0))
}
pnorm(rangeY, est, sd)
}
crps = function(probVec, y, rangeY=NULL) {
if (is.null(rangeY)) {
rangeY = log(pmax(seq(-99,99) + 15, 0))
}
Hy = (rangeY >= y)
mean((probVec-Hy)^2)
}
predictCV = function(theResponse, theData, modelFnc, k=5) {
if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
} else {
cat("other; \n")
modFnc = function(data) {
modelFnc(data[, -1, drop=F], data[, 1])
}
}
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
# select(predicted, y, pred)
# pred = tibble(dfSub$Yards, exp(predicted$pred) - 15)
# index = 200
# mean(predicted$y)
# plot(rangeY, predicted$probEst[[index]])
# abline(v=predicted$y[index])
# ggplot(predicted) +
# geom_point(aes(pred, y-pred))
#wrapper
errorOOS = function(theResponse, theData, fncs, k=5) {
map(fncs, ~ predictCV(theResponse, theData, ., k))
}
theResponse2 = log(pmax(theResponse + 15, 0))
covariates = c("Quarter", "PossessionTeam", "Down", "Distance", "OffenseFormation",
"DefendersInTheBox", "Turf", "GameWeather", "DistanceToGoal", "DistanceToLOS",
"RusherInfo_Acc", "RusherInfo_DistDef", "RusherInfo_DistLOS",
"RusherInfo_Pos", "RusherInfo_SpeedX", "RusherInfo_SpeedY" )
categorical = c("Quarter", "PossessionTeam", "Down", "OffenseFormation", "Turf", "GameWeather", "RusherInfo_Pos")
theData2 = theData %>%
select(covariates) %>%
mutate_at(vars(categorical), as.factor)
modelFnc = rai
# modelFnc = runLM
predictCV(theResponse2, theData2, modelFnc)
dim(TheData)
dim(theData)
library(knitr)
opts_chunk$set(echo = TRUE,
collapse = FALSE,
comment = "",
strip.white = TRUE,
warning = FALSE,
message = FALSE,
out.width = "70%",
fig.align = "center")
library(tidyverse)
library(magrittr)
library(modelr)  # for cv
# devtools::install_github("korydjohnson/rai")
library(rai)
loadData <- function(fileName = "train.csv", ...) {
file = paste("../input", fileName, sep="/")
data.table::fread(file, ...) %>%
as_tibble()
}
theData = loadData("trainClean_py.csv")
theResponse = loadData("trainResponse_py.csv") %>%
pull(Yards)
dim(theData); length(theResponse)
# theData
a = 112.75760456
b = 103.6066858
x = seq(0, 198)/198
beta = dbeta(x, a, b)
dfBeta = tibble(x, beta)
dfBeta %>%
filter(beta > .001) %>%
ggplot() +
geom_line(aes(x*199-99, beta))
mu = a/(a+b)
sig = sqrt(a*b/((a+b)^2*(a+b+1)))
dfBeta %<>%
mutate(normal = dnorm(x, mu, sig))
dfBeta %>%
gather("dist", "density", beta, normal) %>%
filter(density > .01) %>%
ggplot() +
geom_line(aes(x, density, color=dist))
runLM = function(theData, theResponse) {
lm(theResponse ~ ., data=theData)
}
getProbs = function(est, sd, rangeY=NULL) {
if (is.null(rangeY)) {
rangeY = log(pmax(seq(-99,99) + 15, 0))
}
pnorm(rangeY, est, sd)
}
crps = function(probVec, y, rangeY=NULL) {
if (is.null(rangeY)) {
rangeY = log(pmax(seq(-99,99) + 15, 0))
}
Hy = (rangeY >= y)
mean((probVec-Hy)^2)
}
predictCV = function(theResponse, theData, modelFnc, k=5) {
if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
} else {
cat("other; \n")
modFnc = function(data) {
modelFnc(data[, -1, drop=F], data[, 1])
}
}
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
# select(predicted, y, pred)
# pred = tibble(dfSub$Yards, exp(predicted$pred) - 15)
# index = 200
# mean(predicted$y)
# plot(rangeY, predicted$probEst[[index]])
# abline(v=predicted$y[index])
# ggplot(predicted) +
# geom_point(aes(pred, y-pred))
#wrapper
errorOOS = function(theResponse, theData, fncs, k=5) {
map(fncs, ~ predictCV(theResponse, theData, ., k))
}
theResponse2 = log(pmax(theResponse + 15, 0))
covariates = c("Quarter", "PossessionTeam", "Down", "Distance", "OffenseFormation",
"DefendersInTheBox", "Turf", "GameWeather", "DistanceToGoal", "DistanceToLOS",
"RusherInfo_Acc", "RusherInfo_DistDef", "RusherInfo_DistLOS",
"RusherInfo_Pos", "RusherInfo_SpeedX", "RusherInfo_SpeedY" )
categorical = c("Quarter", "PossessionTeam", "Down", "OffenseFormation", "Turf", "GameWeather", "RusherInfo_Pos")
theData2 = theData %>%
select(covariates) %>%
mutate_at(vars(categorical), as.factor)
modelFnc = rai
# modelFnc = runLM
out = predictCV(theResponse2, theData2, modelFnc)
# errorOOS(theResponse, theData2, list("rai"=rai, "lm"=runLM))
out
pull(out, crps)
rai_caret = list(library = "rai",
type = "Regression",
prob = NULL)
# subsampling, start parameter, alpha
rai_caret$parameters = data.frame(parameter = c("alpha", "startDeg"),
class = rep("numeric", 2),
label = c("alpha", "startDeg"))
rai_caret$grid = function(x, y, len=NULL, search = "grid") {
expand.grid(alpha = c(.01, seq(.05,.25,.05)),
startDeg = c(1, .5, 1/3))
}
rai_caret$fit = function(x, y, wts=NULL, param, lev=NULL,
last, weights, classProbs, ...) {
rai::rai(theData = x, theResponse = y, alpha = param$alpha, ...)
}
rai_caret$predict = function(modelFit, newdata, preProc = NULL,
submodels = NULL) {
rai::predict.rai(modelFit, newdata)
}
rai_caret$sort = function(x) x[order(rev(x$startDeg), x$alpha),]
rai_caret$predictors = function(modelFit) {
modelFit$features
}
fitControl <- trainControl(method = "repeatedcv",
number = 5, ## 10-fold CV...
repeats = 5)  ## repeated ten times
library(caret)
rai_caret = list(library = "rai",
type = "Regression",
prob = NULL)
# subsampling, start parameter, alpha
rai_caret$parameters = data.frame(parameter = c("alpha", "startDeg"),
class = rep("numeric", 2),
label = c("alpha", "startDeg"))
rai_caret$grid = function(x, y, len=NULL, search = "grid") {
expand.grid(alpha = c(.01, seq(.05,.25,.05)),
startDeg = c(1, .5, 1/3))
}
rai_caret$fit = function(x, y, wts=NULL, param, lev=NULL,
last, weights, classProbs, ...) {
rai::rai(theData = x, theResponse = y, alpha = param$alpha, ...)
}
rai_caret$predict = function(modelFit, newdata, preProc = NULL,
submodels = NULL) {
rai::predict.rai(modelFit, newdata)
}
rai_caret$sort = function(x) x[order(rev(x$startDeg), x$alpha),]
rai_caret$predictors = function(modelFit) {
modelFit$features
}
fitControl <- trainControl(method = "repeatedcv",
number = 5, ## 10-fold CV...
repeats = 5)  ## repeated ten times
# train(x=theData, y=theResponse, method=rai_caret, trControl = fitControl)
rai_caret$loop = function(grid) {
deg <- unique(grid$startDeg)
loop <- data.frame(startDeg = deg)
loop$alpha <- NA
submodels <- vector(mode = "list", length = length(deg))
for(i in seq(along = deg)) {
np <- grid[grid$startDeg == deg[i],"alpha"]
loop$alpha[loop$startDeg == deg[i]] <- np[which.max(np)]
submodels[[i]] <- data.frame(alpha = np[-which.max(np)])
}
list(loop = loop, submodels = submodels)
}
rai_caret$predict = function(modelFit, newdata, preProc = NULL,
submodels = NULL) {
out = predict(modelFit, newdata)
if(!is.null(submodels)) {
out = list(out)
for(j in seq(along = submodels$alpha)) {
out[[j+1]] <- predict(modelFit, newdata, alpha = submodels$alpha[j])
}
}
out
}
train(x=theData2, y=theResponse2, method=rai_caret, trControl = fitControl)
modelFnc = partial(rai, startDeg=1/3, alpha=.1)
# modelFnc = runLM
out = predictCV(theResponse2, theData2, modelFnc)
predictCV = function(theResponse, theData, modelFnc, k=5) {
# if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
# } else {
#   cat("other; \n")
#   modFnc = function(data) {
#     modelFnc(data[, -1, drop=F], data[, 1])
#   }
# }
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
modelFnc = partial(rai, startDegree=1/3, alpha=.1)
# modelFnc = runLM
out = predictCV(theResponse2, theData2, modelFnc)
theResponse2
length(theResponse2)
dim(theData2)
# modelFnc = runLM
out = predictCV(theResponse2, theData2, modelFnc)
predictCV = function(theResponse, theData, modelFnc, k=5) {
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
# if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
# } else {
#   cat("other; \n")
#   modFnc = function(data) {
#     modelFnc(data[, -1, drop=F], data[, 1])
#   }
# }
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
# modelFnc = runLM
out = predictCV(theResponse2, theData2, modelFnc)
predictCV = function(theResponse, theData, modelFnc, k=5) {
if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
} else {
cat("other; \n")
modFnc = function(data) {
modelFnc(data[, -1, drop=F], data[, 1])
}
}
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
predictCV = function(theResponse, theData, modelFnc, k=5) {
if (any(grepl("runAuction", capture.output(modelFnc)))) {
modFnc = function(data) {
# to send original data; modified it below for use in OOS prediction
theDataO = apply(data[, -1, drop=F], 2, function(col) col^(1/startDeg))
modelFnc(theDataO, data[, 1])$model
}
theData = model.matrix(~. - 1, data=as.data.frame(theData))
startDeg = formals(modelFnc)$startDeg
theData = apply(theData, 2, function(col) col^startDeg)  # modify for OOS
cat("rai", startDeg, ";\n")
} else {
cat("other; \n")
modFnc = function(data) {
modelFnc(data[, -1, drop=F], data[, 1])
}
}
theResponse = as.matrix(theResponse)
data = data.frame(y=theResponse, theData)
data %>% crossv_kfold(k = k) %>%
mutate(
model = map(train, ~modFnc(as.data.frame(.))),
predicted = map2(model, test, ~ add_predictions(as.data.frame(.y), .x)),
sd = map_dbl(model, ~ summary(.)$sigma)
) %>%
select(predicted, sd) %>%
unnest(predicted) %>%
mutate(
probEst = map2(pred, sd, getProbs),
crps = map2_dbl(probEst, y, crps)
) %>%
summarise(crps = mean(crps))
}
